<!doctype html><html lang="en" class=""><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="data:;base64,="><link rel="stylesheet" type="text/css" href="/styles/main.css"><title>Hacks around S-expressions in Lisps</title><link rel="alternate" type="application/atom+xml" title="Mitranim's Posts (Atom)" href="/feed.xml"><link rel="alternate" type="application/rss+xml" title="Mitranim's Posts (RSS)" href="/feed_rss.xml"><meta name="author" content="Nelo Mitranim"><meta property="og:title" content="Hacks around S-expressions in Lisps"><meta name="description" content="How far people are willing to go to get prefix and infix in a Lisp syntax."><meta name="og:description" content="How far people are willing to go to get prefix and infix in a Lisp syntax."><meta property="og:site_name" content="about:mitranim"></head><body id="top"><header class="header"><nav class="flex row-sta-str"><a class="header-link --busy" href="/">home</a><a class="header-link --busy" href="/works">works</a><a class="header-link --busy" href="/posts">posts</a><a class="header-link --busy" href="/games">games</a></nav><span class="flex-1"></span><span class="header-update" aria-label="last update anywhere on the site">updated: 2025-Sep-23</span></header><article role="main" id="main" class="main article"><h1 class="heading-prefix">Hacks around S-expressions in Lisps</h1><p class="post-desc">How far people are willing to go to get prefix and infix in a Lisp syntax.</p><p class="post-time">written 2020-Oct-21, updated 2021-Aug-20</p><p><strong>TLDR</strong>: nobody wants to write pure S-expressions, and Lisps are full of hacks around them.</p>

<p>Disclaimer: Lisps have decades of history and many dialects with a variety of hacks. The following is just what I happened to come across. There might be more.</p>

<p>Examples on this page use <a href="https://racket-lang.org" target="_blank" rel="noopener noreferrer">Racket<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; width: 1.5ex; height: 1.5ex; margin-left: 0.3ch;" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></svg></a>.</p>
<h2 id="definitions" class="heading-prefix">Definitions<a href="#definitions" class="heading-anchor" aria-hidden="true"></a></h2>
<p><a href="https://en.wikipedia.org/wiki/S-expression" target="_blank" rel="noopener noreferrer">S-expressions<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; width: 1.5ex; height: 1.5ex; margin-left: 0.3ch;" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></svg></a> is a syntax for binary trees. The base notation has only atoms, pairs, and nil:</p>

<pre><code>symbol       |    atom
&quot;string&quot;     |    atom
10           |    atom
(10 . 20)    |    pair
()           |    nil
</code></pre>

<p>The &quot;abbreviated&quot; notation omits <code>.</code> from pairs that end with another pair or nil, combining them into lists:</p>

<pre><code>(10)            -&gt;    (10 . ())
(10 20)         -&gt;    (10 . (20 . ()))
(10 20 30)      -&gt;    (10 . (20 . (30 . ())))
(10 20 . 30)    -&gt;    (10 . (20 . 30))
</code></pre>

<p>When talking about S-expressions as code, we usually mean the abbreviated notation, as in Lisps. Writing code in the base notation is out of the question, but pairs will come back to haunt us later. Example Lisp code:</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822">(<span style="color:#66d9ef">define</span> add (<span style="color:#66d9ef">lambda</span> (a b) (+ a b)))

(<span style="color:#66d9ef">define</span> some_var (add <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span>))
</pre><h2 id="why" class="heading-prefix">Why<a href="#why" class="heading-anchor" aria-hidden="true"></a></h2>
<ul>
<li>Extremely simple.</li>
<li>Can express any computation.</li>
<li>Infinitely extensible.</li>
</ul>

<p>We can express new concepts by adding meaning to symbols such as <code>lambda</code>, <code>if</code>, and so on. Each such &quot;form&quot; will have its internal &quot;syntax&quot;, usually extremely simple, but we don't have to change the base notation. The cost of adding and learning new features is lower compared to other syntaxes. This also makes it easy to give <em>users</em> the ability to extend it, via AST-based macros.</p>

<p>Sidenote. Personally I like the S-expression syntax, but advocate against dynamic typing and <a href="/posts/lang-homoiconic">homoiconity</a> as seen in Lisps. We could and should use S-expressions for statically typed languages.</p>
<h2 id="hacks" class="heading-prefix">Hacks<a href="#hacks" class="heading-anchor" aria-hidden="true"></a></h2><h3 id="number-literals" class="heading-prefix">Number Literals<a href="#number-literals" class="heading-anchor" aria-hidden="true"></a></h3>
<p>S-expressions require unary negation to be written like this:</p>

<pre><code>(- num)
(- 10)
</code></pre>

<p>But <code>-10</code> was too hard to give up, so they built <code>+-</code> <em>into number literals</em>. The language's parser supports <code>+10</code> <code>-10</code> where the operator is part of the number's syntax. Note that <code>+ 10</code> <code>- 10</code> (with a space) don't work that way. Of course, this limited special case works <em>only</em> for literal numbers, not variables, and doesn't extend to other unary operators such as bitwise negation.</p>
<h3 id="prefix-operators" class="heading-prefix">Prefix Operators<a href="#prefix-operators" class="heading-anchor" aria-hidden="true"></a></h3>
<p>Despite claiming the opposite, Lisps have always had many prefix operators, not just <code>-10</code>.</p>

<p>Lisps have a concept of &quot;quoting&quot; code. Because the code notation <em>happens</em> to be a data notation, the quoted code can be evaluated as data. This also serves as the language's AST, used internally.</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822"><span style="color:#75715e">; Evaluate as code, result is `30`</span>
(add <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span>)

<span style="color:#75715e">; Evaluate as data, result is `(add 10 20)`</span>
(<span style="color:#66d9ef">quote</span> (<span style="color:#e6db74">add</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span>))
</pre>
<p>Writing <code>(quote)</code> and others was too much, so they added prefix shortcuts.</p>
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822"><span style="color:#f92672">&#39;</span>(<span style="color:#e6db74">add</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span>)       <span style="color:#66d9ef">-&gt;</span>    (<span style="color:#66d9ef">quote</span> (<span style="color:#e6db74">add</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span>))
<span style="color:#f92672">`</span>(<span style="color:#e6db74">add</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span>)       <span style="color:#66d9ef">-&gt;</span>    (<span style="color:#66d9ef">quasiquote</span> (<span style="color:#e6db74">add</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">20</span>))
<span style="color:#f92672">`</span>(<span style="color:#e6db74">add</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">,</span>expr)    <span style="color:#66d9ef">-&gt;</span>    (<span style="color:#66d9ef">quasiquote</span> (<span style="color:#e6db74">add</span> <span style="color:#ae81ff">10</span> (<span style="color:#66d9ef">unquote</span> expr)))
<span style="color:#f92672">`</span>(<span style="color:#e6db74">add</span> <span style="color:#f92672">,@</span>exprs)     <span style="color:#66d9ef">-&gt;</span>    (<span style="color:#66d9ef">quasiquote</span> (<span style="color:#e6db74">add</span> (<span style="color:#66d9ef">unquote-splicing</span> exprs)))
</pre>
<p>In general, all Lisp prefix operators are aliases for &quot;expanded&quot; forms. They're converted after or during parsing text into AST. Parsing text and converting prefix operators is combined into a step called &quot;reading&quot;, which returns a canonical AST.</p>

<p><a href="https://clojure.org/reference/reader" target="_blank" rel="noopener noreferrer">Clojure's reader<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; width: 1.5ex; height: 1.5ex; margin-left: 0.3ch;" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></svg></a> has more prefix operators, such as <code>@A</code> → <code>(deref A)</code>, and a somewhat-generalized <code>#</code>.</p>

<p>Upside: because this is done once at &quot;read time&quot;, no other code has to deal with prefix operators. Downside: standard library and user code either can't define new prefix operators, or must use an API different from functions and macros.</p>
<h3 id="curly-infix" class="heading-prefix">Curly Infix<a href="#curly-infix" class="heading-anchor" aria-hidden="true"></a></h3>
<p>People have written large documents and reference implementations suggesting <code>{}</code> for infix. See <a href="https://srfi.schemers.org/srfi-105/srfi-105.html" target="_blank" rel="noopener noreferrer">SRFI 105<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; width: 1.5ex; height: 1.5ex; margin-left: 0.3ch;" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></svg></a>. Code inside <code>{}</code> would be implicitly and unambiguously converted to the canonical form by the reader.</p>

<pre><code>{10 + 20 + 30}      -&gt;    (+ 10 20 30)
{{10 + 20} * 30}    -&gt;    (* (+ 10 20) 30)
</code></pre>

<p>Veiled in-joke or serious request? Can't tell...</p>

<p>It can be observed that this proposal has grouping, but no precedence. Grouping is both necessary and sufficient. Precedence is not necessary and not sufficient. Programming languages have lots of operators that don't exist in math, and their precedence is inconsistent between languages. Precedence errors are so insidious that some languages, like Pony, ban most forms of operator mixing and enforce grouping. This proposal, while ludicrous in the context of Lisp, has at least one good idea at its core.</p>
<h3 id="racket-infix-hack" class="heading-prefix">Racket Infix Hack<a href="#racket-infix-hack" class="heading-anchor" aria-hidden="true"></a></h3>
<p>Racket has a special infix hack.</p>

<p>Remember the unabbreviated <code>(a . b)</code> syntax for pairs? Racket folks have found unused &quot;dead space&quot; in the syntax they could exploit. In addition to binary <code>(a . b)</code> which makes a <em>pair</em>, it supports ternary <code>(a . b . c)</code> which makes a <em>reordered list</em>. They use <em>one</em> infix operator to enable <em>other</em> infix operators or functions in a &quot;general&quot; way.</p>

<pre><code>(10 . + . 20)               -&gt;    (+ 10 20)
((10 . + . 20) . * . 30)    -&gt;    (* (+ 10 20) 30)
</code></pre>

<p>It's often said that forbidden fruit is desired more strongly. Evidence suggests that when Lisp bereaves its users of infix, they develop a strong desire for more, <em>more</em> infix! (We herd you like infix, so we put more infix in your infix...)</p>
<h3 id="namespacing-in-symbols" class="heading-prefix">Namespacing in Symbols<a href="#namespacing-in-symbols" class="heading-anchor" aria-hidden="true"></a></h3>
<p>Most languages have some form of namespacing. Some mix several forms.</p>

<pre><code>one.two.three
one-&gt;two-&gt;three
one:two:three
one::two::three
one/two.three
</code></pre>

<p>Since inception, Lisps have allowed special characters inside symbols, and avoided infix operators. It naturally followed that Lisp package systems implement namespacing inside symbols. Common Lisp and Racket use <code>:</code>, Clojure uses <code>/</code> and <code>.</code>.</p>

<pre><code>package:identifier
namespace/identifier
value.method
</code></pre>

<p>Still a hack, because <em>useful</em> applications of these symbols involve sub-parsing them. Conceptually, these are separate identifiers combined by an infix operator. The parser (or &quot;reader&quot;) should have parsed them for you, storing the pieces in the AST. That's what Clojure does: its symbols are classes with separate &quot;namespace&quot; and &quot;name&quot; parts.</p>

<p>Sidenote. One simple alternative is to extend &quot;reader macros&quot; by supporting infix <code>:</code>, converting <code>one:two:three</code> to canonical <code>:(one two three)</code>. Lisps already special-case <code>.</code> in a similar way; <code>:</code> would have a higher precedence. As long as there's no other infix, this should parse unambiguously. Alternatively, we could ditch the pair syntax and use <code>.</code> for namespacing. Improper pairs could be printed as <code>(cons a b)</code>.</p>

<p>The major downside of the solution above, aside from added complexity, is that it's non-extensible, as adding more infix would create parsing ambiguities, which we can't resolve because we can't afford <code>()</code> for grouping. I would appreciate a simple and flexible approach that doesn't seem hacky.</p>
<h2 id="conclusion" class="heading-prefix">Conclusion<a href="#conclusion" class="heading-anchor" aria-hidden="true"></a></h2>
<p>If Lisp people haven't been able to stick with pure S-expressions, nobody will. Languages designed for practical use must include common prefix and infix shortcuts. To me, everything above seems hacky or complicated. Elegant approaches are topics for other posts.</p>
</article><hr class="hr mar-ver-1 pad-hor-body"><p class="pad-hor-body">This blog currently doesn't support comments. Write to me via <a href="/#contacts" class="link-deco">contacts</a>.</p><p class="feed-links pad-hor-body"><span>Subscribe using one of:</span><a href="/feed.xml" class="link-deco" target="_blank" rel="noopener noreferrer">Atom‍<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; width: 1.5ex; height: 1.5ex; margin-left: 0.3ch;" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></svg></a><a href="/feed_rss.xml" class="link-deco" target="_blank" rel="noopener noreferrer">RSS‍<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; width: 1.5ex; height: 1.5ex; margin-left: 0.3ch;" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></svg></a><a href="https://feedly.com/i/subscription/feed/https://mitranim.com/feed.xml" class="link-deco" target="_blank" rel="noopener noreferrer">Feedly‍<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; width: 1.5ex; height: 1.5ex; margin-left: 0.3ch;" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></svg></a></p><footer class="footer"><span class="flex-1 flex row-sta-cen gap-hor-0x5 pad-lef-body"><span class="text-lef">2014-2025</span><a href="https://github.com/mitranim/mitranim.github.io" class="link-deco wspace-nowrap" target="_blank" rel="noopener noreferrer">code‍<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display: inline-block; width: 1.5ex; height: 1.5ex; margin-left: 0.3ch;" aria-hidden="true"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6" /><polyline points="15 3 21 3 21 9" /><line x1="10" y1="14" x2="21" y2="3" /></svg></a></span><span class="flex-1 text-cen"><a href="/#contacts" class="link-deco">touch me</a></span><span class="flex-1 flex row-end-cen"><a href="#top" class="fill-gray-fg-near pad-body busy-gray-bg" onclick="event.preventDefault(); window.scrollTo(0, 0)"><svg class="svg-icon fill-fg" viewBox="0 0 448 512" width="1em" height="1em"><path d="M34.9 289.5l-22.2-22.2c-9.4-9.4-9.4-24.6 0-33.9L207 39c9.4-9.4 24.6-9.4 33.9 0l194.3 194.3c9.4 9.4 9.4 24.6 0 33.9L413 289.4c-9.5 9.5-25 9.3-34.3-.4L264 168.6V456c0 13.3-10.7 24-24 24h-32c-13.3 0-24-10.7-24-24V168.6L69.2 289.1c-9.3 9.8-24.8 10-34.3.4z"/></svg></a></span></footer></body></html>